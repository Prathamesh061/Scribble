<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape Drawer and Filler</title>
    <style>
        canvas {
            border: 1px solid #000;
            cursor: crosshair;
        }
    </style>
</head>

<body>
    <canvas id="drawingCanvas" width="1000" height="800"></canvas>
    <input type="color" id="fillColorPicker">
    <button onclick="startDrawing()">Start Drawing</button>
    <button onclick="startFilling()">Start Filling</button>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const fillColorPicker = document.getElementById('fillColorPicker');
        let drawing = false;
        let filling = false;
        let shapes = [];
        let path = [];

        function startDrawing() {
            drawing = true;
            filling = false;
            path = [];
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
        }

        function startFilling() {
            drawing = false;
            filling = true;
        }

        function handleMouseDown(e) {
            const x = e.offsetX;
            const y = e.offsetY;
            if (drawing) {
                path.push({ x, y });
                ctx.strokeStyle = fillColorPicker.value;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                canvas.addEventListener('mousemove', handleMouseMove);
            }
        }

        function handleMouseMove(e) {
            if (!drawing) return;
            const x = e.offsetX;
            const y = e.offsetY;
            path.push({ x, y });
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        function handleMouseUp() {
            if (drawing) {
                if (path.length > 1) {
                    shapes.push(path);
                }
                canvas.removeEventListener('mousemove', handleMouseMove);
            }
        }

        canvas.addEventListener('click', function (e) {
            if (filling) {
                const x = e.offsetX;
                const y = e.offsetY;
                fillArea(x, y);
            }
        });

        function fillArea(x, y) {
            const pixelStack = [{ x, y }];
            const visited = new Array(canvas.width * canvas.height).fill(false);

            while (pixelStack.length) {
                const { x, y } = pixelStack.pop();
                const pixelPos = y * canvas.width + x;

                if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height && !visited[pixelPos]) {
                    const pixel = ctx.getImageData(x, y, 1, 1).data;
                    const targetColor = [0, 0, 0, 0]; // Color of the empty space

                    if (
                        pixel[0] === targetColor[0] &&
                        pixel[1] === targetColor[1] &&
                        pixel[2] === targetColor[2] &&
                        pixel[3] === targetColor[3]
                    ) {
                        ctx.fillStyle = fillColorPicker.value;
                        ctx.fillRect(x, y, 1, 1);
                        visited[pixelPos] = true;

                        pixelStack.push({ x: x + 1, y });
                        pixelStack.push({ x: x - 1, y });
                        pixelStack.push({ x, y: y + 1 });
                        pixelStack.push({ x, y: y - 1 });
                    }
                }
            }
        }
    </script>
</body>

</html>











<!-- 
<!DOCTYPE html>
<html>

<head>
    <style>
        canvas {
            border: 1px solid #000;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="400" height="300"></canvas>
    <button id="pen">Pen</button>
    <button id="eraser">Eraser</button>
    <button id="clear">Clear</button>
    <button id="download">Download</button>
    <button id="increaseSize">Increase Size</button>
    <button id="decreaseSize">Decrease Size</button>
    <button id="undo">Undo</button>
    <button id="redo">Redo</button>
    <button id="fill">Fill</button>
    <select id="colorSelect">
        <option value="black">Black</option>
        <option value="red">Red</option>
        <option value="blue">Blue</option>
        <option value="green">Green</option>
    </select>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        let drawing = false;
        let lastX, lastY;
        let penSize = 2;
        let eraserSize = 10;
        let isErasing = false;

        // Stack to store canvas states for undo and redo
        let canvasStateStack = [];
        let currentStateIndex = -1;

        // Function to save the current canvas state
        function saveCanvasState() {
            currentStateIndex++;
            if (currentStateIndex < canvasStateStack.length) {
                canvasStateStack.length = currentStateIndex;
            }
            canvasStateStack.push(canvas.toDataURL());
        }

        // Function to undo
        function undo() {
            if (currentStateIndex > 0) {
                currentStateIndex--;
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = canvasStateStack[currentStateIndex];
            }
        }

        // Function to redo
        function redo() {
            if (currentStateIndex < canvasStateStack.length - 1) {
                currentStateIndex++;
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = canvasStateStack[currentStateIndex];
            }
        }

        canvas.addEventListener("mousedown", () => {
            drawing = true;
            lastX = event.clientX - canvas.offsetLeft;
            lastY = event.clientY - canvas.offsetTop;
            ctx.beginPath();
        });

        canvas.addEventListener("mouseup", () => {
            drawing = false;
            ctx.closePath();
            saveCanvasState(); // Save the state after each action
        });

        canvas.addEventListener("mousemove", draw);

        canvas.addEventListener("mouseout", () => {
            drawing = false;
        });

        function draw(e) {
            if (!drawing) return;

            const x = e.clientX - canvas.offsetLeft;
            const y = e.clientY - canvas.offsetTop;

            if (isErasing) {
                ctx.clearRect(x - eraserSize / 2, y - eraserSize / 2, eraserSize, eraserSize);
            } else {
                ctx.lineWidth = penSize;
                ctx.lineCap = "round";
                ctx.strokeStyle = "black";
                ctx.lineTo(x, y);
                ctx.stroke();
            }
        }

        document.getElementById("pen").addEventListener("click", () => {
            isErasing = false;
            canvas.style.cursor = "crosshair";
        });

        document.getElementById("eraser").addEventListener("click", () => {
            isErasing = true;
            canvas.style.cursor = "cell";
        });

        document.getElementById("clear").addEventListener("click", () => {
            clearCanvas();
        });

        document.getElementById("download").addEventListener("click", () => {
            downloadCanvas();
        });

        document.getElementById("increaseSize").addEventListener("click", () => {
            if (isErasing) {
                eraserSize += 2;
            } else {
                penSize += 2;
            }
        });

        document.getElementById("decreaseSize").addEventListener("click", () => {
            if (isErasing) {
                eraserSize = Math.max(2, eraserSize - 2);
            } else {
                penSize = Math.max(2, penSize - 2);
            }
        });

        document.getElementById("undo").addEventListener("click", () => {
            undo();
        });

        document.getElementById("redo").addEventListener("click", () => {
            redo();
        });

        document.getElementById("fill").addEventListener("click", () => {
            const fillColor = getSelectedColor();
            fillCanvas(fillColor);
            saveCanvasState(); // Save state after filling
        });

        document.getElementById("colorSelect").addEventListener("change", () => {
            saveCanvasState(); // Save state before changing the fill color
        });

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveCanvasState();
        }

        function downloadCanvas() {
            const link = document.createElement("a");
            link.href = canvas.toDataURL("image/png");
            link.download = "drawing.png";
            link.click();
        }

        function getSelectedColor() {
            const colorSelect = document.getElementById("colorSelect");
            const selectedColor = colorSelect.options[colorSelect.selectedIndex].value;
            const colors = {
                black: [0, 0, 0],
                red: [255, 0, 0],
                blue: [0, 0, 255],
                green: [0, 255, 0]
            };
            return colors[selectedColor];
        }

        // Save initial canvas state
        saveCanvasState();

        // Function to fill the canvas using Flood Fill algorithm
        // ...
        function fillCanvas(targetColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const getColorIndex = (x, y) => (y * canvas.width + x);

            const isSameColor = (x, y, sourceColor) => {
                const index = getColorIndex(x, y);
                const r = imageData.data[index * 4];
                const g = imageData.data[index * 4 + 1];
                const b = imageData.data[index * 4 + 2];
                return r === sourceColor[0] && g === sourceColor[1] && b === sourceColor[2];
            };

            const setColor = (x, y) => {
                const index = getColorIndex(x, y);
                imageData.data[index * 4] = targetColor[0];
                imageData.data[index * 4 + 1] = targetColor[1];
                imageData.data[index * 4 + 2] = targetColor[2];
            };

            const stack = [{ x: lastX, y: lastY }];
            const sourceColor = [...imageData.data.slice(getColorIndex(lastX, lastY) * 4, getColorIndex(lastX, lastY) * 4 + 3)];

            const fillPixel = (x, y) => {
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height || !isSameColor(x, y, sourceColor)) {
                    return;
                }

                setColor(x, y);
                stack.push({ x, y });
            };

            while (stack.length > 0) {
                const { x, y } = stack.pop();

                fillPixel(x + 1, y);
                fillPixel(x - 1, y);
                fillPixel(x, y + 1);
                fillPixel(x, y - 1);
            }

            ctx.putImageData(imageData, 0, 0);
        }







    </script>
</body>

</html> -->